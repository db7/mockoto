#ifndef MOCKOTO_CHICKEN_GEN_HPP
#define MOCKOTO_CHICKEN_GEN_HPP

#include "clang/AST/AST.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendAction.h"
#include "clang/Tooling/Tooling.h"
#include "llvm/ADT/SmallString.h"

#include <algorithm>
#include <cctype>
#include <cstdint>
#include <set>
#include <string>
#include <vector>

#include "Config.hpp"

using namespace clang;

namespace mockoto {

class ChickenGenVisitor : public RecursiveASTVisitor<ChickenGenVisitor> {
  ASTContext *Context;
  mockoto::Config Config;
  llvm::StringRef InFile;
  std::set<std::string> emitted;

public:
  explicit ChickenGenVisitor(ASTContext *Context, mockoto::Config Config,
                             llvm::StringRef InFile)
      : Context(Context), Config(Config), InFile(InFile) {
    llvm::outs() << autogeneratedWarning(";;") << "\n";
    llvm::outs() << ";; This file is intended for CHICKEN with crunch.\n\n";
    llvm::outs() << "(import (chicken base)\n"
                 << "        (chicken foreign)\n"
                 << "        (crunch))\n\n";
    llvm::outs() << "(crunch\n";
    llvm::outs() << "  (import (crunch c)\n"
                 << "          (crunch declarations)\n"
                 << "          (crunch aggregate-types))\n";
    for (auto inFile : Config.includeFiles)
      llvm::outs() << "  (c-include \"" << inFile << "\")\n";
    llvm::outs() << "\n";
  }

  ~ChickenGenVisitor() { llvm::outs() << ")\n"; }

  bool VisitNamedDecl(NamedDecl *NamedDecl) {
    if (!shouldProcess(NamedDecl))
      return true;

    const FunctionDecl *fdecl = dyn_cast<FunctionDecl>(NamedDecl);
    if (fdecl != NULL) {
      emitFunction(fdecl);
      return true;
    }

    const EnumDecl *edecl = dyn_cast<EnumDecl>(NamedDecl);
    if (edecl != NULL) {
      emitEnum(edecl);
      return true;
    }

    const TypedefNameDecl *tdecl = dyn_cast<TypedefNameDecl>(NamedDecl);
    if (tdecl != NULL) {
      emitTypedef(tdecl);
      return true;
    }

    const RecordDecl *rdecl = dyn_cast<RecordDecl>(NamedDecl);
    if (rdecl != NULL) {
      emitRecord(rdecl);
      return true;
    }

    return true;
  }

private:
  static bool endsWith(const std::string &s, const std::string &suffix) {
    if (suffix.size() > s.size())
      return false;
    return std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
  }

  bool shouldProcess(const NamedDecl *decl) const {
    SourceManager &sm = Context->getSourceManager();
    SourceLocation loc = sm.getExpansionLoc(decl->getLocation());
    if (!loc.isValid())
      return false;

    std::string path = sm.getFilename(loc).str();
    if (path.empty())
      return false;

    for (auto pfx : Config.excludePatterns) {
      if (path.find(pfx) != std::string::npos)
        return false;
    }

    if (Config.includeFiles.empty())
      return true;

    for (auto h : Config.includeFiles) {
      if (path == h)
        return true;
      if (endsWith(path, "/" + h))
        return true;
      if (endsWith(path, h))
        return true;
      size_t slash = h.find_last_of("/\\");
      if (slash != std::string::npos) {
        std::string base = h.substr(slash + 1);
        if (!base.empty() && endsWith(path, "/" + base))
          return true;
      }
    }
    return false;
  }

  static std::string toSymbol(const std::string &raw) {
    if (raw.empty())
      return "anon";
    std::string out;
    out.reserve(raw.size());
    for (unsigned char c : raw) {
      if (std::isalnum(c) || c == '_')
        out.push_back((char)c);
      else
        out.push_back('_');
    }
    if (!out.empty() && std::isdigit((unsigned char)out[0]))
      out = "t_" + out;
    return out;
  }

  static std::string toSchemeName(const std::string &raw) {
    std::string out = toSymbol(raw);
    std::replace(out.begin(), out.end(), '_', '-');
    return out;
  }

  static std::string schemeIntType() { return "integer"; }

  static std::string aliasLineIfNeeded(const std::string &alias,
                                       const std::string &canonical) {
    if (alias == canonical)
      return "";
    return "  (define " + alias + " " + canonical + ")\n";
  }

  bool isByteLike(QualType type) const {
    type.removeLocalFastQualifiers();
    if (const ElaboratedType *et =
            dyn_cast<ElaboratedType>(type.getTypePtr())) {
      return isByteLike(et->getNamedType());
    }
    if (const BuiltinType *bt = dyn_cast<BuiltinType>(type.getTypePtr())) {
      switch (bt->getKind()) {
      case BuiltinType::Char_U:
      case BuiltinType::UChar:
      case BuiltinType::Char_S:
      case BuiltinType::SChar:
        return true;
      default:
        return false;
      }
    }
    if (const TypedefType *tt = dyn_cast<TypedefType>(type.getTypePtr())) {
      std::string name = toSymbol(tt->getDecl()->getQualifiedNameAsString());
      if (name == "uint8_t" || name == "int8_t")
        return true;
      return isByteLike(tt->getDecl()->getUnderlyingType());
    }
    return false;
  }

  bool isBoolLike(QualType type) const {
    type.removeLocalFastQualifiers();
    if (const ElaboratedType *et =
            dyn_cast<ElaboratedType>(type.getTypePtr())) {
      return isBoolLike(et->getNamedType());
    }
    if (const BuiltinType *bt = dyn_cast<BuiltinType>(type.getTypePtr())) {
      return bt->getKind() == BuiltinType::Bool;
    }
    if (const TypedefType *tt = dyn_cast<TypedefType>(type.getTypePtr()))
      return isBoolLike(tt->getDecl()->getUnderlyingType());
    return false;
  }

  bool isConstCharPointer(QualType type) const {
    type.removeLocalFastQualifiers();
    if (!type->isPointerType())
      return false;
    QualType p = type->getPointeeType();
    bool isConst = p.isConstQualified();
    p.removeLocalFastQualifiers();
    if (const ElaboratedType *pet = dyn_cast<ElaboratedType>(p.getTypePtr())) {
      p = pet->getNamedType();
      p.removeLocalFastQualifiers();
    }
    if (const BuiltinType *bt = dyn_cast<BuiltinType>(p.getTypePtr())) {
      switch (bt->getKind()) {
      case BuiltinType::Char_S:
      case BuiltinType::Char_U:
      case BuiltinType::SChar:
      case BuiltinType::UChar:
        return isConst;
      default:
        return false;
      }
    }
    return false;
  }

  bool isByValueRecordOrUnion(QualType type) const {
    type.removeLocalFastQualifiers();
    if (type->isPointerType() || type->isReferenceType())
      return false;
    if (const ElaboratedType *et =
            dyn_cast<ElaboratedType>(type.getTypePtr())) {
      return isByValueRecordOrUnion(et->getNamedType());
    }
    if (const TypedefType *tt = dyn_cast<TypedefType>(type.getTypePtr())) {
      return isByValueRecordOrUnion(tt->getDecl()->getUnderlyingType());
    }
    return type->isStructureType() || type->isUnionType();
  }

  bool isCompleteRecordOrUnion(QualType type) const {
    type.removeLocalFastQualifiers();
    if (const ElaboratedType *et =
            dyn_cast<ElaboratedType>(type.getTypePtr())) {
      return isCompleteRecordOrUnion(et->getNamedType());
    }
    if (const TypedefType *tt = dyn_cast<TypedefType>(type.getTypePtr())) {
      return isCompleteRecordOrUnion(tt->getDecl()->getUnderlyingType());
    }
    const RecordType *rt = nullptr;
    if (type->isStructureType())
      rt = type->getAsStructureType();
    else if (type->isUnionType())
      rt = type->getAsUnionType();
    if (rt == nullptr)
      return true;
    return rt->getDecl()->isCompleteDefinition();
  }

  bool isProcessableRecordOrUnion(QualType type) const {
    type.removeLocalFastQualifiers();
    if (const ElaboratedType *et =
            dyn_cast<ElaboratedType>(type.getTypePtr())) {
      return isProcessableRecordOrUnion(et->getNamedType());
    }
    if (const TypedefType *tt = dyn_cast<TypedefType>(type.getTypePtr())) {
      return isProcessableRecordOrUnion(tt->getDecl()->getUnderlyingType());
    }
    const RecordType *rt = nullptr;
    if (type->isStructureType())
      rt = type->getAsStructureType();
    else if (type->isUnionType())
      rt = type->getAsUnionType();
    if (rt == nullptr)
      return true;
    return shouldProcess(rt->getDecl());
  }

  std::string toChickenType(QualType type) const {
    type.removeLocalFastQualifiers();

    if (const ElaboratedType *et =
            dyn_cast<ElaboratedType>(type.getTypePtr())) {
      return toChickenType(et->getNamedType());
    }

    if (type->isPointerType()) {
      if (isConstCharPointer(type))
        return "c-string";
      QualType p = type->getPointeeType();
      p.removeLocalFastQualifiers();
      if (const ElaboratedType *pet = dyn_cast<ElaboratedType>(p.getTypePtr()))
        p = pet->getNamedType();
      if (p->isStructureType() || p->isUnionType()) {
        const RecordType *rt = p->isStructureType() ? p->getAsStructureType()
                                                    : p->getAsUnionType();
        if (rt && isCompleteRecordOrUnion(p) && isProcessableRecordOrUnion(p))
          return "(pointer (struct " +
                 toSymbol(rt->getDecl()->getQualifiedNameAsString()) + "))";
        return "pointer";
      }
      return "pointer";
    }

    if (type->isReferenceType())
      return "pointer";

    if (isBoolLike(type))
      return "boolean";
    if (isByteLike(type))
      return "byte";

    if (type->isVoidType())
      return "void";
    if (type->isEnumeralType())
      return schemeIntType();

    if (const BuiltinType *bt = dyn_cast<BuiltinType>(type.getTypePtr())) {
      switch (bt->getKind()) {
      case BuiltinType::Float:
      case BuiltinType::Double:
        return "double";
      default:
        return schemeIntType();
      }
    }

    if (const TypedefType *tt = dyn_cast<TypedefType>(type.getTypePtr())) {
      QualType ut = tt->getDecl()->getUnderlyingType();
      ut.removeLocalFastQualifiers();
      if (isByValueRecordOrUnion(ut))
        return "pointer";
      return toChickenType(ut);
    }

    if (type->isStructureType() || type->isUnionType())
      return "pointer";

    return schemeIntType();
  }

  std::string toChickenFieldType(QualType type) const {
    type.removeLocalFastQualifiers();
    if (const ConstantArrayType *at = Context->getAsConstantArrayType(type)) {
      return toChickenFieldType(at->getElementType());
    }
    if (isByValueRecordOrUnion(type))
      return "byte";
    std::string t = toChickenType(type);
    if (t == "c-string")
      return "pointer";
    return t;
  }

  static std::string join(const std::vector<std::string> &xs,
                          const std::string &sep) {
    if (xs.empty())
      return "";
    std::string out = xs.front();
    for (size_t i = 1; i < xs.size(); i++)
      out += sep + xs[i];
    return out;
  }

  void emitFunction(const FunctionDecl *decl) {
    if (!decl->hasPrototype() || decl->isVariadic())
      return;
    if (!Config.includeStaticFunctions && decl->getStorageClass() == SC_Static)
      return;

    std::string cName = toSymbol(decl->getQualifiedNameAsString());
    std::string key = "func:" + cName;
    if (emitted.find(key) != emitted.end())
      return;

    auto ftype = decl->getType()->getAs<FunctionProtoType>();
    if (ftype == NULL)
      return;

    if (isByValueRecordOrUnion(ftype->getReturnType()))
      return;
    for (unsigned i = 0; i < ftype->getNumParams(); i++) {
      if (isByValueRecordOrUnion(ftype->getParamType(i)))
        return;
    }

    emitted.insert(key);

    llvm::outs() << "  ;; function " << cName << "\n";
    llvm::outs() << "  (define " << cName << " (c-external \"" << cName
                 << "\" (";
    std::vector<std::string> argTypes;
    for (unsigned i = 0; i < ftype->getNumParams(); i++)
      argTypes.push_back(toChickenType(ftype->getParamType(i)));
    llvm::outs() << join(argTypes, " ");
    llvm::outs() << ") " << toChickenType(ftype->getReturnType()) << "))\n\n";
  }

  std::string enumValueString(const EnumConstantDecl *decl) const {
    llvm::SmallString<32> buf;
    decl->getInitVal().toString(buf, 10);
    return std::string(buf.str());
  }

  void emitEnum(const EnumDecl *decl) {
    if (!decl->isCompleteDefinition())
      return;

    std::string ename = toSymbol(decl->getQualifiedNameAsString());
    if (ename == "anon")
      ename = "anonymous_enum";

    bool emittedAny = false;
    for (auto it = decl->enumerator_begin(); it != decl->enumerator_end();
         it++) {
      std::string cname = toSymbol(it->getNameAsString());
      std::string alias = toSchemeName(cname);
      std::string key = "enumconst:" + cname;
      if (emitted.find(key) != emitted.end())
        continue;
      emitted.insert(key);
      if (!emittedAny) {
        llvm::outs() << "  ;; enum constants " << ename << "\n";
        emittedAny = true;
      }
      llvm::outs() << "  (define " << cname << " " << enumValueString(*it)
                   << ")\n";
      llvm::outs() << aliasLineIfNeeded(alias, cname);
    }
    if (emittedAny)
      llvm::outs() << "\n";
  }

  void emitTypedef(const TypedefNameDecl *decl) {
    std::string cName = toSymbol(decl->getQualifiedNameAsString());
    std::string sName = toSchemeName(cName);
    std::string key = "typedef:" + cName;
    if (emitted.find(key) != emitted.end())
      return;
    emitted.insert(key);

    QualType ut = decl->getUnderlyingType();
    ut.removeLocalFastQualifiers();

    if (ut->isFunctionPointerType()) {
      llvm::outs() << "  ;; typedef " << cName << "\n";
      llvm::outs() << "  (define-type " << cName << " pointer)\n";
      if (sName != cName)
        llvm::outs() << "  (define-type " << sName << " " << cName << ")\n";
      llvm::outs() << "\n";
      return;
    }

    if (isByValueRecordOrUnion(ut)) {
      const RecordType *rt = ut->isStructureType() ? ut->getAsStructureType()
                                                   : ut->getAsUnionType();
      if (rt == NULL || !isCompleteRecordOrUnion(ut) ||
          !isProcessableRecordOrUnion(ut)) {
        llvm::outs() << "  ;; typedef " << cName << "\n";
        llvm::outs() << "  (define-type " << cName << " pointer)\n";
        if (sName != cName)
          llvm::outs() << "  (define-type " << sName << " " << cName << ")\n";
        llvm::outs() << "\n";
        return;
      }
      std::string recName = toSymbol(rt->getDecl()->getQualifiedNameAsString());
      llvm::outs() << "  ;; typedef " << cName << "\n";
      llvm::outs() << "  (define-type " << cName << " (pointer (struct "
                   << recName << ")))\n";
      if (sName != cName)
        llvm::outs() << "  (define-type " << sName << " " << cName << ")\n";
      llvm::outs() << "\n";
      return;
    }

    std::string mapped = toChickenType(ut);
    if (mapped == cName)
      return;

    llvm::outs() << "  ;; typedef " << cName << "\n";
    llvm::outs() << "  (define-type " << cName << " " << mapped << ")\n";
    if (sName != cName)
      llvm::outs() << "  (define-type " << sName << " " << cName << ")\n";
    llvm::outs() << "\n";
  }

  static std::string fallbackFieldName(unsigned idx) {
    return "field_" + std::to_string(idx);
  }

  static uint64_t max1(uint64_t n) { return n == 0 ? 1 : n; }

  void emitRecord(const RecordDecl *decl) {
    if (!decl->isCompleteDefinition())
      return;
    if (decl->isAnonymousStructOrUnion())
      return;

    std::string name = toSymbol(decl->getQualifiedNameAsString());
    if (name.empty() || name == "anon")
      return;

    std::string key = std::string(decl->isUnion() ? "union:" : "struct:") + name;
    if (emitted.find(key) != emitted.end())
      return;
    emitted.insert(key);

    std::string sname = toSchemeName(name);
    std::vector<std::string> ctorFields;
    struct Accessor {
      std::string cField;
      std::string getter;
      std::string setter;
    };
    std::vector<Accessor> accessors;

    llvm::outs() << "  ;; " << (decl->isUnion() ? "union " : "struct ") << name
                 << "\n";
    llvm::outs() << "  (declare-struct " << name << "\n";

    unsigned idx = 0;
    for (auto it = decl->field_begin(); it != decl->field_end(); it++, idx++) {
      std::string rawField = it->getNameAsString();
      if (rawField.empty())
        rawField = fallbackFieldName(idx);
      std::string cField = toSymbol(rawField);
      QualType ftype = it->getType();
      ftype.removeLocalFastQualifiers();

      if (const ConstantArrayType *at = Context->getAsConstantArrayType(ftype)) {
        llvm::outs() << "    ((" << cField << " "
                     << at->getSize().getLimitedValue() << ") "
                     << toChickenFieldType(at->getElementType()) << ")\n";
        continue;
      }

      if (const IncompleteArrayType *iat =
              dyn_cast<IncompleteArrayType>(ftype.getTypePtr())) {
        (void)iat;
        uint64_t bytes = max1(Context->getTypeSize(ftype) / 8);
        llvm::outs() << "    ((" << cField << " " << bytes << ") byte)\n";
        continue;
      }

      if (isByValueRecordOrUnion(ftype)) {
        uint64_t bytes = max1(Context->getTypeSize(ftype) / 8);
        llvm::outs() << "    ((" << cField << " " << bytes << ") byte)\n";
        continue;
      }

      std::string ctype = toChickenFieldType(ftype);
      llvm::outs() << "    (" << cField << " " << ctype << ")\n";
      ctorFields.push_back(cField);
      std::string fScheme = toSchemeName(rawField);
      std::string getter = sname + "-" + fScheme;
      std::string setter = getter + "!";
      accessors.push_back({cField, getter, setter});
    }
    llvm::outs() << "  )\n";

    if (!accessors.empty() || !ctorFields.empty()) {
      llvm::outs() << "  (define-compound-accessors (pointer (struct " << name
                   << "))\n";
      llvm::outs() << "    (make-" << sname;
      for (auto field : ctorFields)
        llvm::outs() << " " << field;
      llvm::outs() << ")\n";
      for (auto a : accessors) {
        llvm::outs() << "    (" << a.cField << " " << a.getter << " "
                     << a.setter << ")\n";
      }
      llvm::outs() << "  )\n";
    }
    llvm::outs() << "\n";
  }
};

} // namespace mockoto

#endif
